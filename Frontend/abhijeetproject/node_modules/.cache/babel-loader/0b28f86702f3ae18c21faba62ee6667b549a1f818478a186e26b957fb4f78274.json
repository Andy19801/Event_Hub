{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.arrowFunctionToExpression = arrowFunctionToExpression;\nexports.ensureBlock = ensureBlock;\nexports.ensureFunctionName = ensureFunctionName;\nexports.splitExportDeclaration = splitExportDeclaration;\nexports.toComputedKey = toComputedKey;\nexports.unwrapFunctionEnvironment = unwrapFunctionEnvironment;\nvar _t = require(\"@babel/types\");\nvar _template = require(\"@babel/template\");\nvar _visitors = require(\"../visitors.js\");\nvar _context = require(\"./context.js\");\nconst {\n  arrowFunctionExpression,\n  assignmentExpression,\n  binaryExpression,\n  blockStatement,\n  callExpression,\n  conditionalExpression,\n  expressionStatement,\n  identifier,\n  isIdentifier,\n  jsxIdentifier,\n  logicalExpression,\n  LOGICAL_OPERATORS,\n  memberExpression,\n  metaProperty,\n  numericLiteral,\n  objectExpression,\n  restElement,\n  returnStatement,\n  sequenceExpression,\n  spreadElement,\n  stringLiteral,\n  super: _super,\n  thisExpression,\n  toExpression,\n  unaryExpression,\n  toBindingIdentifierName,\n  isFunction,\n  isAssignmentPattern,\n  isRestElement,\n  getFunctionName,\n  cloneNode,\n  variableDeclaration,\n  variableDeclarator,\n  exportNamedDeclaration,\n  exportSpecifier,\n  inherits\n} = _t;\nfunction toComputedKey() {\n  let key;\n  if (this.isMemberExpression()) {\n    key = this.node.property;\n  } else if (this.isProperty() || this.isMethod()) {\n    key = this.node.key;\n  } else {\n    throw new ReferenceError(\"todo\");\n  }\n  if (!this.node.computed) {\n    if (isIdentifier(key)) key = stringLiteral(key.name);\n  }\n  return key;\n}\nfunction ensureBlock() {\n  const body = this.get(\"body\");\n  const bodyNode = body.node;\n  if (Array.isArray(body)) {\n    throw new Error(\"Can't convert array path to a block statement\");\n  }\n  if (!bodyNode) {\n    throw new Error(\"Can't convert node without a body\");\n  }\n  if (body.isBlockStatement()) {\n    return bodyNode;\n  }\n  const statements = [];\n  let stringPath = \"body\";\n  let key;\n  let listKey;\n  if (body.isStatement()) {\n    listKey = \"body\";\n    key = 0;\n    statements.push(body.node);\n  } else {\n    stringPath += \".body.0\";\n    if (this.isFunction()) {\n      key = \"argument\";\n      statements.push(returnStatement(body.node));\n    } else {\n      key = \"expression\";\n      statements.push(expressionStatement(body.node));\n    }\n  }\n  this.node.body = blockStatement(statements);\n  const parentPath = this.get(stringPath);\n  _context.setup.call(body, parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key);\n  return this.node;\n}\n{\n  exports.arrowFunctionToShadowed = function () {\n    if (!this.isArrowFunctionExpression()) return;\n    this.arrowFunctionToExpression();\n  };\n}\nfunction unwrapFunctionEnvironment() {\n  if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {\n    throw this.buildCodeFrameError(\"Can only unwrap the environment of a function.\");\n  }\n  hoistFunctionEnvironment(this);\n}\nfunction setType(path, type) {\n  path.node.type = type;\n}\nfunction arrowFunctionToExpression() {\n  let {\n    allowInsertArrow = true,\n    allowInsertArrowWithRest = allowInsertArrow,\n    noNewArrows = !(_arguments$ => (_arguments$ = arguments[0]) == null ? void 0 : _arguments$.specCompliant)()\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  if (!this.isArrowFunctionExpression()) {\n    throw this.buildCodeFrameError(\"Cannot convert non-arrow function to a function expression.\");\n  }\n  let self = this;\n  if (!noNewArrows) {\n    var _self$ensureFunctionN;\n    self = (_self$ensureFunctionN = self.ensureFunctionName(false)) != null ? _self$ensureFunctionN : self;\n  }\n  const {\n    thisBinding,\n    fnPath: fn\n  } = hoistFunctionEnvironment(self, noNewArrows, allowInsertArrow, allowInsertArrowWithRest);\n  fn.ensureBlock();\n  setType(fn, \"FunctionExpression\");\n  if (!noNewArrows) {\n    const checkBinding = thisBinding ? null : fn.scope.generateUidIdentifier(\"arrowCheckId\");\n    if (checkBinding) {\n      fn.parentPath.scope.push({\n        id: checkBinding,\n        init: objectExpression([])\n      });\n    }\n    fn.get(\"body\").unshiftContainer(\"body\", expressionStatement(callExpression(this.hub.addHelper(\"newArrowCheck\"), [thisExpression(), checkBinding ? identifier(checkBinding.name) : identifier(thisBinding)])));\n    fn.replaceWith(callExpression(memberExpression(fn.node, identifier(\"bind\")), [checkBinding ? identifier(checkBinding.name) : thisExpression()]));\n    return fn.get(\"callee.object\");\n  }\n  return fn;\n}\nconst getSuperCallsVisitor = (0, _visitors.environmentVisitor)({\n  CallExpression(child, _ref) {\n    let {\n      allSuperCalls\n    } = _ref;\n    if (!child.get(\"callee\").isSuper()) return;\n    allSuperCalls.push(child);\n  }\n});\nfunction hoistFunctionEnvironment(fnPath) {\n  let noNewArrows = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  let allowInsertArrow = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  let allowInsertArrowWithRest = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  let arrowParent;\n  let thisEnvFn = fnPath.findParent(p => {\n    if (p.isArrowFunctionExpression()) {\n      var _arrowParent;\n      (_arrowParent = arrowParent) != null ? _arrowParent : arrowParent = p;\n      return false;\n    }\n    return p.isFunction() || p.isProgram() || p.isClassProperty({\n      static: false\n    }) || p.isClassPrivateProperty({\n      static: false\n    });\n  });\n  const inConstructor = thisEnvFn.isClassMethod({\n    kind: \"constructor\"\n  });\n  if (thisEnvFn.isClassProperty() || thisEnvFn.isClassPrivateProperty()) {\n    if (arrowParent) {\n      thisEnvFn = arrowParent;\n    } else if (allowInsertArrow) {\n      fnPath.replaceWith(callExpression(arrowFunctionExpression([], toExpression(fnPath.node)), []));\n      thisEnvFn = fnPath.get(\"callee\");\n      fnPath = thisEnvFn.get(\"body\");\n    } else {\n      throw fnPath.buildCodeFrameError(\"Unable to transform arrow inside class property\");\n    }\n  }\n  const {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  } = getScopeInformation(fnPath);\n  if (inConstructor && superCalls.length > 0) {\n    if (!allowInsertArrow) {\n      throw superCalls[0].buildCodeFrameError(\"When using '@babel/plugin-transform-arrow-functions', \" + \"it's not possible to compile `super()` in an arrow function without compiling classes.\\n\" + \"Please add '@babel/plugin-transform-classes' to your Babel configuration.\");\n    }\n    if (!allowInsertArrowWithRest) {\n      throw superCalls[0].buildCodeFrameError(\"When using '@babel/plugin-transform-parameters', \" + \"it's not possible to compile `super()` in an arrow function with default or rest parameters without compiling classes.\\n\" + \"Please add '@babel/plugin-transform-classes' to your Babel configuration.\");\n    }\n    const allSuperCalls = [];\n    thisEnvFn.traverse(getSuperCallsVisitor, {\n      allSuperCalls\n    });\n    const superBinding = getSuperBinding(thisEnvFn);\n    allSuperCalls.forEach(superCall => {\n      const callee = identifier(superBinding);\n      callee.loc = superCall.node.callee.loc;\n      superCall.get(\"callee\").replaceWith(callee);\n    });\n  }\n  if (argumentsPaths.length > 0) {\n    const argumentsBinding = getBinding(thisEnvFn, \"arguments\", () => {\n      const args = () => identifier(\"arguments\");\n      if (thisEnvFn.scope.path.isProgram()) {\n        return conditionalExpression(binaryExpression(\"===\", unaryExpression(\"typeof\", args()), stringLiteral(\"undefined\")), thisEnvFn.scope.buildUndefinedNode(), args());\n      } else {\n        return args();\n      }\n    });\n    argumentsPaths.forEach(argumentsChild => {\n      const argsRef = identifier(argumentsBinding);\n      argsRef.loc = argumentsChild.node.loc;\n      argumentsChild.replaceWith(argsRef);\n    });\n  }\n  if (newTargetPaths.length > 0) {\n    const newTargetBinding = getBinding(thisEnvFn, \"newtarget\", () => metaProperty(identifier(\"new\"), identifier(\"target\")));\n    newTargetPaths.forEach(targetChild => {\n      const targetRef = identifier(newTargetBinding);\n      targetRef.loc = targetChild.node.loc;\n      targetChild.replaceWith(targetRef);\n    });\n  }\n  if (superProps.length > 0) {\n    if (!allowInsertArrow) {\n      throw superProps[0].buildCodeFrameError(\"When using '@babel/plugin-transform-arrow-functions', \" + \"it's not possible to compile `super.prop` in an arrow function without compiling classes.\\n\" + \"Please add '@babel/plugin-transform-classes' to your Babel configuration.\");\n    }\n    const flatSuperProps = superProps.reduce((acc, superProp) => acc.concat(standardizeSuperProperty(superProp)), []);\n    flatSuperProps.forEach(superProp => {\n      const key = superProp.node.computed ? \"\" : superProp.get(\"property\").node.name;\n      const superParentPath = superProp.parentPath;\n      const isAssignment = superParentPath.isAssignmentExpression({\n        left: superProp.node\n      });\n      const isCall = superParentPath.isCallExpression({\n        callee: superProp.node\n      });\n      const isTaggedTemplate = superParentPath.isTaggedTemplateExpression({\n        tag: superProp.node\n      });\n      const superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);\n      const args = [];\n      if (superProp.node.computed) {\n        args.push(superProp.get(\"property\").node);\n      }\n      if (isAssignment) {\n        const value = superParentPath.node.right;\n        args.push(value);\n      }\n      const call = callExpression(identifier(superBinding), args);\n      if (isCall) {\n        superParentPath.unshiftContainer(\"arguments\", thisExpression());\n        superProp.replaceWith(memberExpression(call, identifier(\"call\")));\n        thisPaths.push(superParentPath.get(\"arguments.0\"));\n      } else if (isAssignment) {\n        superParentPath.replaceWith(call);\n      } else if (isTaggedTemplate) {\n        superProp.replaceWith(callExpression(memberExpression(call, identifier(\"bind\"), false), [thisExpression()]));\n        thisPaths.push(superProp.get(\"arguments.0\"));\n      } else {\n        superProp.replaceWith(call);\n      }\n    });\n  }\n  let thisBinding;\n  if (thisPaths.length > 0 || !noNewArrows) {\n    thisBinding = getThisBinding(thisEnvFn, inConstructor);\n    if (noNewArrows || inConstructor && hasSuperClass(thisEnvFn)) {\n      thisPaths.forEach(thisChild => {\n        const thisRef = thisChild.isJSX() ? jsxIdentifier(thisBinding) : identifier(thisBinding);\n        thisRef.loc = thisChild.node.loc;\n        thisChild.replaceWith(thisRef);\n      });\n      if (!noNewArrows) thisBinding = null;\n    }\n  }\n  return {\n    thisBinding,\n    fnPath\n  };\n}\nfunction isLogicalOp(op) {\n  return LOGICAL_OPERATORS.includes(op);\n}\nfunction standardizeSuperProperty(superProp) {\n  if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== \"=\") {\n    const assignmentPath = superProp.parentPath;\n    const op = assignmentPath.node.operator.slice(0, -1);\n    const value = assignmentPath.node.right;\n    const isLogicalAssignment = isLogicalOp(op);\n    if (superProp.node.computed) {\n      const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n      const object = superProp.node.object;\n      const property = superProp.node.property;\n      assignmentPath.get(\"left\").replaceWith(memberExpression(object, assignmentExpression(\"=\", tmp, property), true));\n      assignmentPath.get(\"right\").replaceWith(rightExpression(isLogicalAssignment ? \"=\" : op, memberExpression(object, identifier(tmp.name), true), value));\n    } else {\n      const object = superProp.node.object;\n      const property = superProp.node.property;\n      assignmentPath.get(\"left\").replaceWith(memberExpression(object, property));\n      assignmentPath.get(\"right\").replaceWith(rightExpression(isLogicalAssignment ? \"=\" : op, memberExpression(object, identifier(property.name)), value));\n    }\n    if (isLogicalAssignment) {\n      assignmentPath.replaceWith(logicalExpression(op, assignmentPath.node.left, assignmentPath.node.right));\n    } else {\n      assignmentPath.node.operator = \"=\";\n    }\n    return [assignmentPath.get(\"left\"), assignmentPath.get(\"right\").get(\"left\")];\n  } else if (superProp.parentPath.isUpdateExpression()) {\n    const updateExpr = superProp.parentPath;\n    const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n    const computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier(\"prop\") : null;\n    const parts = [assignmentExpression(\"=\", tmp, memberExpression(superProp.node.object, computedKey ? assignmentExpression(\"=\", computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)), assignmentExpression(\"=\", memberExpression(superProp.node.object, computedKey ? identifier(computedKey.name) : superProp.node.property, superProp.node.computed), binaryExpression(superProp.parentPath.node.operator[0], identifier(tmp.name), numericLiteral(1)))];\n    if (!superProp.parentPath.node.prefix) {\n      parts.push(identifier(tmp.name));\n    }\n    updateExpr.replaceWith(sequenceExpression(parts));\n    const left = updateExpr.get(\"expressions.0.right\");\n    const right = updateExpr.get(\"expressions.1.left\");\n    return [left, right];\n  }\n  return [superProp];\n  function rightExpression(op, left, right) {\n    if (op === \"=\") {\n      return assignmentExpression(\"=\", left, right);\n    } else {\n      return binaryExpression(op, left, right);\n    }\n  }\n}\nfunction hasSuperClass(thisEnvFn) {\n  return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;\n}\nconst assignSuperThisVisitor = (0, _visitors.environmentVisitor)({\n  CallExpression(child, _ref2) {\n    let {\n      supers,\n      thisBinding\n    } = _ref2;\n    if (!child.get(\"callee\").isSuper()) return;\n    if (supers.has(child.node)) return;\n    supers.add(child.node);\n    child.replaceWithMultiple([child.node, assignmentExpression(\"=\", identifier(thisBinding), identifier(\"this\"))]);\n  }\n});\nfunction getThisBinding(thisEnvFn, inConstructor) {\n  return getBinding(thisEnvFn, \"this\", thisBinding => {\n    if (!inConstructor || !hasSuperClass(thisEnvFn)) return thisExpression();\n    thisEnvFn.traverse(assignSuperThisVisitor, {\n      supers: new WeakSet(),\n      thisBinding\n    });\n  });\n}\nfunction getSuperBinding(thisEnvFn) {\n  return getBinding(thisEnvFn, \"supercall\", () => {\n    const argsBinding = thisEnvFn.scope.generateUidIdentifier(\"args\");\n    return arrowFunctionExpression([restElement(argsBinding)], callExpression(_super(), [spreadElement(identifier(argsBinding.name))]));\n  });\n}\nfunction getSuperPropBinding(thisEnvFn, isAssignment, propName) {\n  const op = isAssignment ? \"set\" : \"get\";\n  return getBinding(thisEnvFn, `superprop_${op}:${propName || \"\"}`, () => {\n    const argsList = [];\n    let fnBody;\n    if (propName) {\n      fnBody = memberExpression(_super(), identifier(propName));\n    } else {\n      const method = thisEnvFn.scope.generateUidIdentifier(\"prop\");\n      argsList.unshift(method);\n      fnBody = memberExpression(_super(), identifier(method.name), true);\n    }\n    if (isAssignment) {\n      const valueIdent = thisEnvFn.scope.generateUidIdentifier(\"value\");\n      argsList.push(valueIdent);\n      fnBody = assignmentExpression(\"=\", fnBody, identifier(valueIdent.name));\n    }\n    return arrowFunctionExpression(argsList, fnBody);\n  });\n}\nfunction getBinding(thisEnvFn, key, init) {\n  const cacheKey = \"binding:\" + key;\n  let data = thisEnvFn.getData(cacheKey);\n  if (!data) {\n    const id = thisEnvFn.scope.generateUidIdentifier(key);\n    data = id.name;\n    thisEnvFn.setData(cacheKey, data);\n    thisEnvFn.scope.push({\n      id: id,\n      init: init(data)\n    });\n  }\n  return data;\n}\nconst getScopeInformationVisitor = (0, _visitors.environmentVisitor)({\n  ThisExpression(child, _ref3) {\n    let {\n      thisPaths\n    } = _ref3;\n    thisPaths.push(child);\n  },\n  JSXIdentifier(child, _ref4) {\n    let {\n      thisPaths\n    } = _ref4;\n    if (child.node.name !== \"this\") return;\n    if (!child.parentPath.isJSXMemberExpression({\n      object: child.node\n    }) && !child.parentPath.isJSXOpeningElement({\n      name: child.node\n    })) {\n      return;\n    }\n    thisPaths.push(child);\n  },\n  CallExpression(child, _ref5) {\n    let {\n      superCalls\n    } = _ref5;\n    if (child.get(\"callee\").isSuper()) superCalls.push(child);\n  },\n  MemberExpression(child, _ref6) {\n    let {\n      superProps\n    } = _ref6;\n    if (child.get(\"object\").isSuper()) superProps.push(child);\n  },\n  Identifier(child, _ref7) {\n    let {\n      argumentsPaths\n    } = _ref7;\n    if (!child.isReferencedIdentifier({\n      name: \"arguments\"\n    })) return;\n    let curr = child.scope;\n    do {\n      if (curr.hasOwnBinding(\"arguments\")) {\n        curr.rename(\"arguments\");\n        return;\n      }\n      if (curr.path.isFunction() && !curr.path.isArrowFunctionExpression()) {\n        break;\n      }\n    } while (curr = curr.parent);\n    argumentsPaths.push(child);\n  },\n  MetaProperty(child, _ref8) {\n    let {\n      newTargetPaths\n    } = _ref8;\n    if (!child.get(\"meta\").isIdentifier({\n      name: \"new\"\n    })) return;\n    if (!child.get(\"property\").isIdentifier({\n      name: \"target\"\n    })) return;\n    newTargetPaths.push(child);\n  }\n});\nfunction getScopeInformation(fnPath) {\n  const thisPaths = [];\n  const argumentsPaths = [];\n  const newTargetPaths = [];\n  const superProps = [];\n  const superCalls = [];\n  fnPath.traverse(getScopeInformationVisitor, {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  });\n  return {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  };\n}\nfunction splitExportDeclaration() {\n  if (!this.isExportDeclaration() || this.isExportAllDeclaration()) {\n    throw new Error(\"Only default and named export declarations can be split.\");\n  }\n  if (this.isExportNamedDeclaration() && this.get(\"specifiers\").length > 0) {\n    throw new Error(\"It doesn't make sense to split exported specifiers.\");\n  }\n  const declaration = this.get(\"declaration\");\n  if (this.isExportDefaultDeclaration()) {\n    const standaloneDeclaration = declaration.isFunctionDeclaration() || declaration.isClassDeclaration();\n    const exportExpr = declaration.isFunctionExpression() || declaration.isClassExpression();\n    const scope = declaration.isScope() ? declaration.scope.parent : declaration.scope;\n    let id = declaration.node.id;\n    let needBindingRegistration = false;\n    if (!id) {\n      needBindingRegistration = true;\n      id = scope.generateUidIdentifier(\"default\");\n      if (standaloneDeclaration || exportExpr) {\n        declaration.node.id = cloneNode(id);\n      }\n    } else if (exportExpr && scope.hasBinding(id.name)) {\n      needBindingRegistration = true;\n      id = scope.generateUidIdentifier(id.name);\n    }\n    const updatedDeclaration = standaloneDeclaration ? declaration.node : variableDeclaration(\"var\", [variableDeclarator(cloneNode(id), declaration.node)]);\n    const updatedExportDeclaration = exportNamedDeclaration(null, [exportSpecifier(cloneNode(id), identifier(\"default\"))]);\n    this.insertAfter(updatedExportDeclaration);\n    this.replaceWith(updatedDeclaration);\n    if (needBindingRegistration) {\n      scope.registerDeclaration(this);\n    }\n    return this;\n  } else if (this.get(\"specifiers\").length > 0) {\n    throw new Error(\"It doesn't make sense to split exported specifiers.\");\n  }\n  const bindingIdentifiers = declaration.getOuterBindingIdentifiers();\n  const specifiers = Object.keys(bindingIdentifiers).map(name => {\n    return exportSpecifier(identifier(name), identifier(name));\n  });\n  const aliasDeclar = exportNamedDeclaration(null, specifiers);\n  this.insertAfter(aliasDeclar);\n  this.replaceWith(declaration.node);\n  return this;\n}\nconst refersOuterBindingVisitor = {\n  \"ReferencedIdentifier|BindingIdentifier\"(path, state) {\n    if (path.node.name !== state.name) return;\n    state.needsRename = true;\n    path.stop();\n  },\n  Scope(path, state) {\n    if (path.scope.hasOwnBinding(state.name)) {\n      path.skip();\n    }\n  }\n};\nfunction ensureFunctionName(supportUnicodeId) {\n  if (this.node.id) return this;\n  const res = getFunctionName(this.node, this.parent);\n  if (res == null) return this;\n  let {\n    name\n  } = res;\n  if (!supportUnicodeId && /[\\uD800-\\uDFFF]/.test(name)) {\n    return null;\n  }\n  if (name.startsWith(\"get \") || name.startsWith(\"set \")) {\n    return null;\n  }\n  name = toBindingIdentifierName(name.replace(/[/ ]/g, \"_\"));\n  const id = identifier(name);\n  inherits(id, res.originalNode);\n  const state = {\n    needsRename: false,\n    name\n  };\n  const {\n    scope\n  } = this;\n  const binding = scope.getOwnBinding(name);\n  if (binding) {\n    if (binding.kind === \"param\") {\n      state.needsRename = true;\n    } else {}\n  } else if (scope.parent.hasBinding(name) || scope.hasGlobal(name)) {\n    this.traverse(refersOuterBindingVisitor, state);\n  }\n  if (!state.needsRename) {\n    this.node.id = id;\n    scope.getProgramParent().references[id.name] = true;\n    return this;\n  }\n  if (scope.hasBinding(id.name) && !scope.hasGlobal(id.name)) {\n    scope.rename(id.name);\n    this.node.id = id;\n    scope.getProgramParent().references[id.name] = true;\n    return this;\n  }\n  if (!isFunction(this.node)) return null;\n  const key = scope.generateUidIdentifier(id.name);\n  const params = [];\n  for (let i = 0, len = getFunctionArity(this.node); i < len; i++) {\n    params.push(scope.generateUidIdentifier(\"x\"));\n  }\n  const call = _template.default.expression.ast`\n    (function (${key}) {\n      function ${id}(${params}) {\n        return ${cloneNode(key)}.apply(this, arguments);\n      }\n\n      ${cloneNode(id)}.toString = function () {\n        return ${cloneNode(key)}.toString();\n      }\n\n      return ${cloneNode(id)};\n    })(${toExpression(this.node)})\n  `;\n  return this.replaceWith(call)[0].get(\"arguments.0\");\n}\nfunction getFunctionArity(node) {\n  const count = node.params.findIndex(param => isAssignmentPattern(param) || isRestElement(param));\n  return count === -1 ? node.params.length : count;\n}","map":{"version":3,"names":["_t","require","_template","_visitors","_context","arrowFunctionExpression","assignmentExpression","binaryExpression","blockStatement","callExpression","conditionalExpression","expressionStatement","identifier","isIdentifier","jsxIdentifier","logicalExpression","LOGICAL_OPERATORS","memberExpression","metaProperty","numericLiteral","objectExpression","restElement","returnStatement","sequenceExpression","spreadElement","stringLiteral","super","_super","thisExpression","toExpression","unaryExpression","toBindingIdentifierName","isFunction","isAssignmentPattern","isRestElement","getFunctionName","cloneNode","variableDeclaration","variableDeclarator","exportNamedDeclaration","exportSpecifier","inherits","toComputedKey","key","isMemberExpression","node","property","isProperty","isMethod","ReferenceError","computed","name","ensureBlock","body","get","bodyNode","Array","isArray","Error","isBlockStatement","statements","stringPath","listKey","isStatement","push","parentPath","setup","call","exports","arrowFunctionToShadowed","isArrowFunctionExpression","arrowFunctionToExpression","unwrapFunctionEnvironment","isFunctionExpression","isFunctionDeclaration","buildCodeFrameError","hoistFunctionEnvironment","setType","path","type","allowInsertArrow","allowInsertArrowWithRest","noNewArrows","_arguments$","arguments","specCompliant","length","undefined","self","_self$ensureFunctionN","ensureFunctionName","thisBinding","fnPath","fn","checkBinding","scope","generateUidIdentifier","id","init","unshiftContainer","hub","addHelper","replaceWith","getSuperCallsVisitor","environmentVisitor","CallExpression","child","_ref","allSuperCalls","isSuper","arrowParent","thisEnvFn","findParent","p","_arrowParent","isProgram","isClassProperty","static","isClassPrivateProperty","inConstructor","isClassMethod","kind","thisPaths","argumentsPaths","newTargetPaths","superProps","superCalls","getScopeInformation","traverse","superBinding","getSuperBinding","forEach","superCall","callee","loc","argumentsBinding","getBinding","args","buildUndefinedNode","argumentsChild","argsRef","newTargetBinding","targetChild","targetRef","flatSuperProps","reduce","acc","superProp","concat","standardizeSuperProperty","superParentPath","isAssignment","isAssignmentExpression","left","isCall","isCallExpression","isTaggedTemplate","isTaggedTemplateExpression","tag","getSuperPropBinding","value","right","getThisBinding","hasSuperClass","thisChild","thisRef","isJSX","isLogicalOp","op","includes","operator","assignmentPath","slice","isLogicalAssignment","tmp","generateDeclaredUidIdentifier","object","rightExpression","isUpdateExpression","updateExpr","computedKey","parts","prefix","superClass","assignSuperThisVisitor","_ref2","supers","has","add","replaceWithMultiple","WeakSet","argsBinding","propName","argsList","fnBody","method","unshift","valueIdent","cacheKey","data","getData","setData","getScopeInformationVisitor","ThisExpression","_ref3","JSXIdentifier","_ref4","isJSXMemberExpression","isJSXOpeningElement","_ref5","MemberExpression","_ref6","Identifier","_ref7","isReferencedIdentifier","curr","hasOwnBinding","rename","parent","MetaProperty","_ref8","splitExportDeclaration","isExportDeclaration","isExportAllDeclaration","isExportNamedDeclaration","declaration","isExportDefaultDeclaration","standaloneDeclaration","isClassDeclaration","exportExpr","isClassExpression","isScope","needBindingRegistration","hasBinding","updatedDeclaration","updatedExportDeclaration","insertAfter","registerDeclaration","bindingIdentifiers","getOuterBindingIdentifiers","specifiers","Object","keys","map","aliasDeclar","refersOuterBindingVisitor","ReferencedIdentifier|BindingIdentifier","state","needsRename","stop","Scope","skip","supportUnicodeId","res","test","startsWith","replace","originalNode","binding","getOwnBinding","hasGlobal","getProgramParent","references","params","i","len","getFunctionArity","default","expression","ast","count","findIndex","param"],"sources":["G:\\Event Event Hub\\Frontend\\abhijeetproject\\node_modules\\@babel\\traverse\\src\\path\\conversion.ts"],"sourcesContent":["// This file contains methods that convert the path node into another node or some other type of data.\n\nimport {\n  arrowFunctionExpression,\n  assignmentExpression,\n  binaryExpression,\n  blockStatement,\n  callExpression,\n  conditionalExpression,\n  expressionStatement,\n  identifier,\n  isIdentifier,\n  jsxIdentifier,\n  logicalExpression,\n  LOGICAL_OPERATORS,\n  memberExpression,\n  metaProperty,\n  numericLiteral,\n  objectExpression,\n  restElement,\n  returnStatement,\n  sequenceExpression,\n  spreadElement,\n  stringLiteral,\n  super as _super,\n  thisExpression,\n  toExpression,\n  unaryExpression,\n  toBindingIdentifierName,\n  isFunction,\n  isAssignmentPattern,\n  isRestElement,\n  getFunctionName,\n  cloneNode,\n  variableDeclaration,\n  variableDeclarator,\n  exportNamedDeclaration,\n  exportSpecifier,\n  inherits,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport template from \"@babel/template\";\nimport { environmentVisitor } from \"../visitors.ts\";\nimport type NodePath from \"./index.ts\";\nimport type { Visitor } from \"../types.ts\";\nimport { setup } from \"./context.ts\";\n\nexport function toComputedKey(this: NodePath) {\n  let key;\n  if (this.isMemberExpression()) {\n    key = this.node.property;\n  } else if (this.isProperty() || this.isMethod()) {\n    key = this.node.key;\n  } else {\n    throw new ReferenceError(\"todo\");\n  }\n\n  // @ts-expect-error todo(flow->ts) computed does not exist in ClassPrivateProperty\n  if (!this.node.computed) {\n    if (isIdentifier(key)) key = stringLiteral(key.name);\n  }\n\n  return key;\n}\n\nexport function ensureBlock(\n  this: NodePath<\n    t.Loop | t.WithStatement | t.Function | t.LabeledStatement | t.CatchClause\n  >,\n): void {\n  const body = this.get(\"body\");\n  const bodyNode = body.node;\n\n  if (Array.isArray(body)) {\n    throw new Error(\"Can't convert array path to a block statement\");\n  }\n  if (!bodyNode) {\n    throw new Error(\"Can't convert node without a body\");\n  }\n\n  if (body.isBlockStatement()) {\n    // @ts-expect-error TS throws because ensureBlock returns the body node path\n    // however, we don't use the return value and treat it as a transform and\n    // assertion utilities. For better type inference we annotate it as an\n    // assertion method\n    // TODO: Unify the implementation with the type definition\n    return bodyNode;\n  }\n\n  const statements: Array<t.Statement> = [];\n\n  let stringPath = \"body\";\n  let key;\n  let listKey;\n  if (body.isStatement()) {\n    listKey = \"body\";\n    key = 0;\n    statements.push(body.node);\n  } else {\n    stringPath += \".body.0\";\n    if (this.isFunction()) {\n      key = \"argument\";\n      statements.push(returnStatement(body.node as t.Expression));\n    } else {\n      key = \"expression\";\n      statements.push(expressionStatement(body.node as t.Expression));\n    }\n  }\n\n  this.node.body = blockStatement(statements);\n  const parentPath = this.get(stringPath) as NodePath;\n  setup.call(\n    body,\n    parentPath,\n    listKey\n      ? // @ts-expect-error listKey must present in parent path\n        parentPath.node[listKey]\n      : parentPath.node,\n    listKey,\n    key,\n  );\n\n  // @ts-expect-error TS throws because ensureBlock returns the body node path\n  // however, we don't use the return value and treat it as a transform and\n  // assertion utilities. For better type inference we annotate it as an\n  // assertion method\n  // TODO: Unify the implementation with the type definition\n  return this.node;\n}\n\nif (!process.env.BABEL_8_BREAKING && !USE_ESM) {\n  /**\n   * Keeping this for backward-compatibility. You should use arrowFunctionToExpression() for >=7.x.\n   */\n  // eslint-disable-next-line no-restricted-globals\n  exports.arrowFunctionToShadowed = function (this: NodePath) {\n    if (!this.isArrowFunctionExpression()) return;\n\n    this.arrowFunctionToExpression();\n  };\n}\n\n/**\n * Given an arbitrary function, process its content as if it were an arrow function, moving references\n * to \"this\", \"arguments\", \"super\", and such into the function's parent scope. This method is useful if\n * you have wrapped some set of items in an IIFE or other function, but want \"this\", \"arguments\", and super\"\n * to continue behaving as expected.\n */\nexport function unwrapFunctionEnvironment(this: NodePath) {\n  if (\n    !this.isArrowFunctionExpression() &&\n    !this.isFunctionExpression() &&\n    !this.isFunctionDeclaration()\n  ) {\n    throw this.buildCodeFrameError(\n      \"Can only unwrap the environment of a function.\",\n    );\n  }\n\n  hoistFunctionEnvironment(this);\n}\n\nfunction setType<N extends t.Node, T extends N[\"type\"]>(\n  path: NodePath<N>,\n  type: T,\n): asserts path is NodePath<Extract<N, { type: T }>> {\n  path.node.type = type;\n}\n\n/**\n * Convert a given arrow function into a normal ES5 function expression.\n */\nexport function arrowFunctionToExpression(\n  this: NodePath<t.ArrowFunctionExpression>,\n  {\n    allowInsertArrow = true,\n    allowInsertArrowWithRest = allowInsertArrow,\n    noNewArrows = process.env.BABEL_8_BREAKING\n      ? // TODO(Babel 8): Consider defaulting to `false` for spec compliance\n        true\n      : !arguments[0]?.specCompliant,\n  }: {\n    allowInsertArrow?: boolean | void;\n    allowInsertArrowWithRest?: boolean | void;\n    noNewArrows?: boolean;\n  } = {},\n): NodePath<\n  Exclude<t.Function, t.Method | t.ArrowFunctionExpression> | t.CallExpression\n> {\n  if (!this.isArrowFunctionExpression()) {\n    throw (this as NodePath).buildCodeFrameError(\n      \"Cannot convert non-arrow function to a function expression.\",\n    );\n  }\n\n  let self = this;\n  if (!noNewArrows) {\n    // @ts-expect-error This is technicallynot valid on arrow functions\n    // because it adds an .id property, but we are going to convert it\n    // to a function expression anyway\n    self = self.ensureFunctionName(false) ?? self;\n  }\n\n  const { thisBinding, fnPath: fn } = hoistFunctionEnvironment(\n    self,\n    noNewArrows,\n    allowInsertArrow,\n    allowInsertArrowWithRest,\n  );\n\n  fn.ensureBlock();\n  setType(fn, \"FunctionExpression\");\n\n  if (!noNewArrows) {\n    const checkBinding = thisBinding\n      ? null\n      : fn.scope.generateUidIdentifier(\"arrowCheckId\");\n    if (checkBinding) {\n      fn.parentPath.scope.push({\n        id: checkBinding,\n        init: objectExpression([]),\n      });\n    }\n\n    fn.get(\"body\").unshiftContainer(\n      \"body\",\n      expressionStatement(\n        callExpression(this.hub.addHelper(\"newArrowCheck\"), [\n          thisExpression(),\n          checkBinding\n            ? identifier(checkBinding.name)\n            : identifier(thisBinding),\n        ]),\n      ),\n    );\n\n    fn.replaceWith(\n      callExpression(memberExpression(fn.node, identifier(\"bind\")), [\n        checkBinding ? identifier(checkBinding.name) : thisExpression(),\n      ]),\n    );\n\n    return fn.get(\"callee.object\");\n  }\n\n  return fn;\n}\n\nconst getSuperCallsVisitor = environmentVisitor<{\n  allSuperCalls: NodePath<t.CallExpression>[];\n}>({\n  CallExpression(child, { allSuperCalls }) {\n    if (!child.get(\"callee\").isSuper()) return;\n    allSuperCalls.push(child);\n  },\n});\n\n/**\n * Given a function, traverse its contents, and if there are references to \"this\", \"arguments\", \"super\",\n * or \"new.target\", ensure that these references reference the parent environment around this function.\n *\n * @returns `thisBinding`: the name of the injected reference to `this`; for example \"_this\"\n * @returns `fnPath`: the new path to the function node. This is different from the fnPath\n *                    parameter when the function node is wrapped in another node.\n */\nfunction hoistFunctionEnvironment(\n  fnPath: NodePath<t.Function>,\n  // TODO(Babel 8): Consider defaulting to `false` for spec compliance\n  noNewArrows: boolean | void = true,\n  allowInsertArrow: boolean | void = true,\n  allowInsertArrowWithRest: boolean | void = true,\n): { thisBinding: string; fnPath: NodePath<t.Function> } {\n  let arrowParent;\n  let thisEnvFn: NodePath<t.Function> = fnPath.findParent(p => {\n    if (p.isArrowFunctionExpression()) {\n      arrowParent ??= p;\n      return false;\n    }\n    return (\n      p.isFunction() ||\n      p.isProgram() ||\n      p.isClassProperty({ static: false }) ||\n      p.isClassPrivateProperty({ static: false })\n    );\n  }) as NodePath<t.Function>;\n  const inConstructor = thisEnvFn.isClassMethod({ kind: \"constructor\" });\n\n  if (thisEnvFn.isClassProperty() || thisEnvFn.isClassPrivateProperty()) {\n    if (arrowParent) {\n      thisEnvFn = arrowParent;\n    } else if (allowInsertArrow) {\n      // It's safe to wrap this function in another and not hoist to the\n      // top level because the 'this' binding is constant in class\n      // properties (since 'super()' has already been called), so we don't\n      // need to capture/reassign it at the top level.\n      fnPath.replaceWith(\n        callExpression(\n          arrowFunctionExpression([], toExpression(fnPath.node)),\n          [],\n        ),\n      );\n      thisEnvFn = fnPath.get(\"callee\") as NodePath<t.ArrowFunctionExpression>;\n      fnPath = thisEnvFn.get(\"body\") as NodePath<t.FunctionExpression>;\n    } else {\n      throw fnPath.buildCodeFrameError(\n        \"Unable to transform arrow inside class property\",\n      );\n    }\n  }\n\n  const { thisPaths, argumentsPaths, newTargetPaths, superProps, superCalls } =\n    getScopeInformation(fnPath);\n\n  // Convert all super() calls in the constructor, if super is used in an arrow.\n  if (inConstructor && superCalls.length > 0) {\n    if (!allowInsertArrow) {\n      throw superCalls[0].buildCodeFrameError(\n        \"When using '@babel/plugin-transform-arrow-functions', \" +\n          \"it's not possible to compile `super()` in an arrow function without compiling classes.\\n\" +\n          \"Please add '@babel/plugin-transform-classes' to your Babel configuration.\",\n      );\n    }\n    if (!allowInsertArrowWithRest) {\n      // preset-env with target `since 2017` enables `transform-parameters` without `transform-classes`.\n      throw superCalls[0].buildCodeFrameError(\n        \"When using '@babel/plugin-transform-parameters', \" +\n          \"it's not possible to compile `super()` in an arrow function with default or rest parameters without compiling classes.\\n\" +\n          \"Please add '@babel/plugin-transform-classes' to your Babel configuration.\",\n      );\n    }\n    const allSuperCalls: NodePath<t.CallExpression>[] = [];\n    thisEnvFn.traverse(getSuperCallsVisitor, { allSuperCalls });\n    const superBinding = getSuperBinding(thisEnvFn);\n    allSuperCalls.forEach(superCall => {\n      const callee = identifier(superBinding);\n      callee.loc = superCall.node.callee.loc;\n\n      superCall.get(\"callee\").replaceWith(callee);\n    });\n  }\n\n  // Convert all \"arguments\" references in the arrow to point at the alias.\n  if (argumentsPaths.length > 0) {\n    const argumentsBinding = getBinding(thisEnvFn, \"arguments\", () => {\n      const args = () => identifier(\"arguments\");\n      if (thisEnvFn.scope.path.isProgram()) {\n        return conditionalExpression(\n          binaryExpression(\n            \"===\",\n            unaryExpression(\"typeof\", args()),\n            stringLiteral(\"undefined\"),\n          ),\n          thisEnvFn.scope.buildUndefinedNode(),\n          args(),\n        );\n      } else {\n        return args();\n      }\n    });\n\n    argumentsPaths.forEach(argumentsChild => {\n      const argsRef = identifier(argumentsBinding);\n      argsRef.loc = argumentsChild.node.loc;\n\n      argumentsChild.replaceWith(argsRef);\n    });\n  }\n\n  // Convert all \"new.target\" references in the arrow to point at the alias.\n  if (newTargetPaths.length > 0) {\n    const newTargetBinding = getBinding(thisEnvFn, \"newtarget\", () =>\n      metaProperty(identifier(\"new\"), identifier(\"target\")),\n    );\n\n    newTargetPaths.forEach(targetChild => {\n      const targetRef = identifier(newTargetBinding);\n      targetRef.loc = targetChild.node.loc;\n\n      targetChild.replaceWith(targetRef);\n    });\n  }\n\n  // Convert all \"super.prop\" references to point at aliases.\n  if (superProps.length > 0) {\n    if (!allowInsertArrow) {\n      throw superProps[0].buildCodeFrameError(\n        \"When using '@babel/plugin-transform-arrow-functions', \" +\n          \"it's not possible to compile `super.prop` in an arrow function without compiling classes.\\n\" +\n          \"Please add '@babel/plugin-transform-classes' to your Babel configuration.\",\n      );\n    }\n\n    const flatSuperProps: NodePath<t.MemberExpression>[] = superProps.reduce(\n      (acc, superProp) => acc.concat(standardizeSuperProperty(superProp)),\n      [],\n    );\n\n    flatSuperProps.forEach(superProp => {\n      const key = superProp.node.computed\n        ? \"\"\n        : // @ts-expect-error super property must not contain private name\n          superProp.get(\"property\").node.name;\n\n      const superParentPath = superProp.parentPath;\n\n      const isAssignment = superParentPath.isAssignmentExpression({\n        left: superProp.node,\n      });\n      const isCall = superParentPath.isCallExpression({\n        callee: superProp.node,\n      });\n      const isTaggedTemplate = superParentPath.isTaggedTemplateExpression({\n        tag: superProp.node,\n      });\n      const superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);\n\n      const args: t.Expression[] = [];\n      if (superProp.node.computed) {\n        // SuperProperty must not be a private name\n        args.push(superProp.get(\"property\").node as t.Expression);\n      }\n\n      if (isAssignment) {\n        const value = superParentPath.node.right;\n        args.push(value);\n      }\n\n      const call = callExpression(identifier(superBinding), args);\n\n      if (isCall) {\n        superParentPath.unshiftContainer(\"arguments\", thisExpression());\n        superProp.replaceWith(memberExpression(call, identifier(\"call\")));\n\n        thisPaths.push(\n          superParentPath.get(\"arguments.0\") as NodePath<t.ThisExpression>,\n        );\n      } else if (isAssignment) {\n        // Replace not only the super.prop, but the whole assignment\n        superParentPath.replaceWith(call);\n      } else if (isTaggedTemplate) {\n        superProp.replaceWith(\n          callExpression(memberExpression(call, identifier(\"bind\"), false), [\n            thisExpression(),\n          ]),\n        );\n\n        thisPaths.push(\n          superProp.get(\"arguments.0\") as NodePath<t.ThisExpression>,\n        );\n      } else {\n        superProp.replaceWith(call);\n      }\n    });\n  }\n\n  // Convert all \"this\" references in the arrow to point at the alias.\n  let thisBinding: string | null;\n  if (thisPaths.length > 0 || !noNewArrows) {\n    thisBinding = getThisBinding(thisEnvFn, inConstructor);\n\n    if (\n      noNewArrows ||\n      // In subclass constructors, still need to rewrite because \"this\" can't be bound in spec mode\n      // because it might not have been initialized yet.\n      (inConstructor && hasSuperClass(thisEnvFn))\n    ) {\n      thisPaths.forEach(thisChild => {\n        const thisRef = thisChild.isJSX()\n          ? jsxIdentifier(thisBinding)\n          : identifier(thisBinding);\n\n        thisRef.loc = thisChild.node.loc;\n        thisChild.replaceWith(thisRef);\n      });\n\n      if (!noNewArrows) thisBinding = null;\n    }\n  }\n\n  return { thisBinding, fnPath };\n}\n\ntype LogicalOp = Parameters<typeof logicalExpression>[0];\ntype BinaryOp = Parameters<typeof binaryExpression>[0];\n\nfunction isLogicalOp(op: string): op is LogicalOp {\n  return LOGICAL_OPERATORS.includes(op);\n}\n\nfunction standardizeSuperProperty(\n  superProp: NodePath<t.MemberExpression>,\n):\n  | [NodePath<t.MemberExpression>]\n  | [NodePath<t.MemberExpression>, NodePath<t.MemberExpression>] {\n  if (\n    superProp.parentPath.isAssignmentExpression() &&\n    superProp.parentPath.node.operator !== \"=\"\n  ) {\n    const assignmentPath = superProp.parentPath;\n\n    const op = assignmentPath.node.operator.slice(0, -1) as\n      | LogicalOp\n      | BinaryOp;\n\n    const value = assignmentPath.node.right;\n\n    const isLogicalAssignment = isLogicalOp(op);\n\n    if (superProp.node.computed) {\n      // from: super[foo] **= 4;\n      // to:   super[tmp = foo] = super[tmp] ** 4;\n\n      // from: super[foo] ??= 4;\n      // to:   super[tmp = foo] ?? super[tmp] = 4;\n\n      const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n\n      const object = superProp.node.object;\n      const property = superProp.node.property as t.Expression;\n\n      assignmentPath\n        .get(\"left\")\n        .replaceWith(\n          memberExpression(\n            object,\n            assignmentExpression(\"=\", tmp, property),\n            true /* computed */,\n          ),\n        );\n\n      assignmentPath\n        .get(\"right\")\n        .replaceWith(\n          rightExpression(\n            isLogicalAssignment ? \"=\" : op,\n            memberExpression(object, identifier(tmp.name), true /* computed */),\n            value,\n          ),\n        );\n    } else {\n      // from: super.foo **= 4;\n      // to:   super.foo = super.foo ** 4;\n\n      // from: super.foo ??= 4;\n      // to:   super.foo ?? super.foo = 4;\n\n      const object = superProp.node.object;\n      const property = superProp.node.property as t.Identifier;\n\n      assignmentPath\n        .get(\"left\")\n        .replaceWith(memberExpression(object, property));\n\n      assignmentPath\n        .get(\"right\")\n        .replaceWith(\n          rightExpression(\n            isLogicalAssignment ? \"=\" : op,\n            memberExpression(object, identifier(property.name)),\n            value,\n          ),\n        );\n    }\n\n    if (isLogicalAssignment) {\n      assignmentPath.replaceWith(\n        logicalExpression(\n          op,\n          assignmentPath.node.left as t.MemberExpression,\n          assignmentPath.node.right,\n        ),\n      );\n    } else {\n      assignmentPath.node.operator = \"=\";\n    }\n\n    return [\n      assignmentPath.get(\"left\") as NodePath<t.MemberExpression>,\n      assignmentPath.get(\"right\").get(\"left\") as NodePath<t.MemberExpression>,\n    ];\n  } else if (superProp.parentPath.isUpdateExpression()) {\n    const updateExpr = superProp.parentPath;\n\n    const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n    const computedKey = superProp.node.computed\n      ? superProp.scope.generateDeclaredUidIdentifier(\"prop\")\n      : null;\n\n    const parts: t.Expression[] = [\n      assignmentExpression(\n        \"=\",\n        tmp,\n        memberExpression(\n          superProp.node.object,\n          computedKey\n            ? assignmentExpression(\n                \"=\",\n                computedKey,\n                superProp.node.property as t.Expression,\n              )\n            : superProp.node.property,\n          superProp.node.computed,\n        ),\n      ),\n      assignmentExpression(\n        \"=\",\n        memberExpression(\n          superProp.node.object,\n          computedKey ? identifier(computedKey.name) : superProp.node.property,\n          superProp.node.computed,\n        ),\n        binaryExpression(\n          // map `++` to `+`, and `--` to `-`\n          superProp.parentPath.node.operator[0] as \"+\" | \"-\",\n          identifier(tmp.name),\n          numericLiteral(1),\n        ),\n      ),\n    ];\n\n    if (!superProp.parentPath.node.prefix) {\n      parts.push(identifier(tmp.name));\n    }\n\n    updateExpr.replaceWith(sequenceExpression(parts));\n\n    const left = updateExpr.get(\n      \"expressions.0.right\",\n    ) as NodePath<t.MemberExpression>;\n    const right = updateExpr.get(\n      \"expressions.1.left\",\n    ) as NodePath<t.MemberExpression>;\n    return [left, right];\n  }\n\n  return [superProp];\n\n  function rightExpression(\n    op: BinaryOp | \"=\",\n    left: t.MemberExpression,\n    right: t.Expression,\n  ) {\n    if (op === \"=\") {\n      return assignmentExpression(\"=\", left, right);\n    } else {\n      return binaryExpression(op, left, right);\n    }\n  }\n}\n\nfunction hasSuperClass(thisEnvFn: NodePath<t.Function>) {\n  return (\n    thisEnvFn.isClassMethod() &&\n    !!(thisEnvFn.parentPath.parentPath.node as t.Class).superClass\n  );\n}\n\nconst assignSuperThisVisitor = environmentVisitor<{\n  supers: WeakSet<t.CallExpression>;\n  thisBinding: string;\n}>({\n  CallExpression(child, { supers, thisBinding }) {\n    if (!child.get(\"callee\").isSuper()) return;\n    if (supers.has(child.node)) return;\n    supers.add(child.node);\n\n    child.replaceWithMultiple([\n      child.node,\n      assignmentExpression(\"=\", identifier(thisBinding), identifier(\"this\")),\n    ]);\n  },\n});\n\n// Create a binding that evaluates to the \"this\" of the given function.\nfunction getThisBinding(\n  thisEnvFn: NodePath<t.Function>,\n  inConstructor: boolean,\n) {\n  return getBinding(thisEnvFn, \"this\", thisBinding => {\n    if (!inConstructor || !hasSuperClass(thisEnvFn)) return thisExpression();\n\n    thisEnvFn.traverse(assignSuperThisVisitor, {\n      supers: new WeakSet(),\n      thisBinding,\n    });\n  });\n}\n\n// Create a binding for a function that will call \"super()\" with arguments passed through.\nfunction getSuperBinding(thisEnvFn: NodePath<t.Function>) {\n  return getBinding(thisEnvFn, \"supercall\", () => {\n    const argsBinding = thisEnvFn.scope.generateUidIdentifier(\"args\");\n    return arrowFunctionExpression(\n      [restElement(argsBinding)],\n      callExpression(_super(), [spreadElement(identifier(argsBinding.name))]),\n    );\n  });\n}\n\n// Create a binding for a function that will call \"super.foo\" or \"super[foo]\".\nfunction getSuperPropBinding(\n  thisEnvFn: NodePath<t.Function>,\n  isAssignment: boolean,\n  propName: string,\n) {\n  const op = isAssignment ? \"set\" : \"get\";\n\n  return getBinding(thisEnvFn, `superprop_${op}:${propName || \"\"}`, () => {\n    const argsList = [];\n\n    let fnBody;\n    if (propName) {\n      // () => super.foo\n      fnBody = memberExpression(_super(), identifier(propName));\n    } else {\n      const method = thisEnvFn.scope.generateUidIdentifier(\"prop\");\n      // (method) => super[method]\n      argsList.unshift(method);\n      fnBody = memberExpression(\n        _super(),\n        identifier(method.name),\n        true /* computed */,\n      );\n    }\n\n    if (isAssignment) {\n      const valueIdent = thisEnvFn.scope.generateUidIdentifier(\"value\");\n      argsList.push(valueIdent);\n\n      fnBody = assignmentExpression(\"=\", fnBody, identifier(valueIdent.name));\n    }\n\n    return arrowFunctionExpression(argsList, fnBody);\n  });\n}\n\nfunction getBinding(\n  thisEnvFn: NodePath,\n  key: string,\n  init: (name: string) => t.Expression,\n) {\n  const cacheKey = \"binding:\" + key;\n  let data: string | undefined = thisEnvFn.getData(cacheKey);\n  if (!data) {\n    const id = thisEnvFn.scope.generateUidIdentifier(key);\n    data = id.name;\n    thisEnvFn.setData(cacheKey, data);\n\n    thisEnvFn.scope.push({\n      id: id,\n      init: init(data),\n    });\n  }\n\n  return data;\n}\n\ntype ScopeInfo = {\n  thisPaths: NodePath<t.ThisExpression | t.JSXIdentifier>[];\n  superCalls: NodePath<t.CallExpression>[];\n  superProps: NodePath<t.MemberExpression>[];\n  argumentsPaths: NodePath<t.Identifier | t.JSXIdentifier>[];\n  newTargetPaths: NodePath<t.MetaProperty>[];\n};\n\nconst getScopeInformationVisitor = environmentVisitor<ScopeInfo>({\n  ThisExpression(child, { thisPaths }) {\n    thisPaths.push(child);\n  },\n  JSXIdentifier(child, { thisPaths }) {\n    if (child.node.name !== \"this\") return;\n    if (\n      !child.parentPath.isJSXMemberExpression({ object: child.node }) &&\n      !child.parentPath.isJSXOpeningElement({ name: child.node })\n    ) {\n      return;\n    }\n\n    thisPaths.push(child);\n  },\n  CallExpression(child, { superCalls }) {\n    if (child.get(\"callee\").isSuper()) superCalls.push(child);\n  },\n  MemberExpression(child, { superProps }) {\n    if (child.get(\"object\").isSuper()) superProps.push(child);\n  },\n  Identifier(child, { argumentsPaths }) {\n    if (!child.isReferencedIdentifier({ name: \"arguments\" })) return;\n\n    let curr = child.scope;\n    do {\n      if (curr.hasOwnBinding(\"arguments\")) {\n        curr.rename(\"arguments\");\n        return;\n      }\n      if (curr.path.isFunction() && !curr.path.isArrowFunctionExpression()) {\n        break;\n      }\n    } while ((curr = curr.parent));\n\n    argumentsPaths.push(child);\n  },\n  MetaProperty(child, { newTargetPaths }) {\n    if (!child.get(\"meta\").isIdentifier({ name: \"new\" })) return;\n    if (!child.get(\"property\").isIdentifier({ name: \"target\" })) return;\n\n    newTargetPaths.push(child);\n  },\n});\n\nfunction getScopeInformation(fnPath: NodePath) {\n  const thisPaths: ScopeInfo[\"thisPaths\"] = [];\n  const argumentsPaths: ScopeInfo[\"argumentsPaths\"] = [];\n  const newTargetPaths: ScopeInfo[\"newTargetPaths\"] = [];\n  const superProps: ScopeInfo[\"superProps\"] = [];\n  const superCalls: ScopeInfo[\"superCalls\"] = [];\n\n  fnPath.traverse(getScopeInformationVisitor, {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls,\n  });\n\n  return {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls,\n  };\n}\n\nexport function splitExportDeclaration(\n  this: NodePath<t.ExportDefaultDeclaration | t.ExportNamedDeclaration>,\n): NodePath<t.Declaration> {\n  if (!this.isExportDeclaration() || this.isExportAllDeclaration()) {\n    throw new Error(\"Only default and named export declarations can be split.\");\n  }\n  if (this.isExportNamedDeclaration() && this.get(\"specifiers\").length > 0) {\n    throw new Error(\"It doesn't make sense to split exported specifiers.\");\n  }\n\n  const declaration = this.get(\"declaration\");\n\n  if (this.isExportDefaultDeclaration()) {\n    const standaloneDeclaration =\n      declaration.isFunctionDeclaration() || declaration.isClassDeclaration();\n    const exportExpr =\n      declaration.isFunctionExpression() || declaration.isClassExpression();\n\n    const scope = declaration.isScope()\n      ? declaration.scope.parent\n      : declaration.scope;\n\n    // @ts-expect-error id is not defined in expressions other than function/class\n    let id = declaration.node.id;\n    let needBindingRegistration = false;\n\n    if (!id) {\n      needBindingRegistration = true;\n\n      id = scope.generateUidIdentifier(\"default\");\n\n      if (standaloneDeclaration || exportExpr) {\n        declaration.node.id = cloneNode(id);\n      }\n    } else if (exportExpr && scope.hasBinding(id.name)) {\n      needBindingRegistration = true;\n\n      id = scope.generateUidIdentifier(id.name);\n    }\n\n    const updatedDeclaration = standaloneDeclaration\n      ? declaration.node\n      : variableDeclaration(\"var\", [\n          variableDeclarator(\n            cloneNode(id),\n            // @ts-expect-error When `standaloneDeclaration` is false, declaration must not be a Function/ClassDeclaration\n            declaration.node,\n          ),\n        ]);\n\n    const updatedExportDeclaration = exportNamedDeclaration(null, [\n      exportSpecifier(cloneNode(id), identifier(\"default\")),\n    ]);\n\n    this.insertAfter(updatedExportDeclaration);\n    this.replaceWith(updatedDeclaration);\n\n    if (needBindingRegistration) {\n      scope.registerDeclaration(this);\n    }\n\n    return this;\n  } else if (this.get(\"specifiers\").length > 0) {\n    throw new Error(\"It doesn't make sense to split exported specifiers.\");\n  }\n\n  const bindingIdentifiers = declaration.getOuterBindingIdentifiers();\n\n  const specifiers = Object.keys(bindingIdentifiers).map(name => {\n    return exportSpecifier(identifier(name), identifier(name));\n  });\n\n  const aliasDeclar = exportNamedDeclaration(null, specifiers);\n\n  this.insertAfter(aliasDeclar);\n  this.replaceWith(declaration.node);\n  return this;\n}\n\nconst refersOuterBindingVisitor: Visitor<{\n  needsRename: boolean;\n  name: string;\n}> = {\n  \"ReferencedIdentifier|BindingIdentifier\"(\n    path: NodePath<t.Identifier>,\n    state,\n  ) {\n    // check if this node matches our function id\n    if (path.node.name !== state.name) return;\n    state.needsRename = true;\n    path.stop();\n  },\n  Scope(path, state) {\n    if (path.scope.hasOwnBinding(state.name)) {\n      path.skip();\n    }\n  },\n};\n\nexport function ensureFunctionName<\n  N extends t.FunctionExpression | t.ClassExpression,\n>(this: NodePath<N>, supportUnicodeId: boolean): null | NodePath<N> {\n  if (this.node.id) return this;\n\n  const res = getFunctionName(this.node, this.parent);\n  if (res == null) return this;\n  let { name } = res;\n\n  if (!supportUnicodeId && /[\\uD800-\\uDFFF]/.test(name)) {\n    return null;\n  }\n\n  if (name.startsWith(\"get \") || name.startsWith(\"set \")) {\n    // TODO: Remove this to support naming getters and setters\n    return null;\n  }\n\n  name = toBindingIdentifierName(name.replace(/[/ ]/g, \"_\"));\n  const id = identifier(name);\n  inherits(id, res.originalNode);\n\n  const state = { needsRename: false, name };\n\n  // check to see if we have a local binding of the id we're setting inside of\n  // the function, this is important as there are caveats associated\n\n  const { scope } = this;\n  const binding = scope.getOwnBinding(name);\n  if (binding) {\n    if (binding.kind === \"param\") {\n      // safari will blow up in strict mode with code like:\n      //\n      //   let t = function t(t) {};\n      //\n      // with the error:\n      //\n      //   Cannot declare a parameter named 't' as it shadows the name of a\n      //   strict mode function.\n      //\n      // this isn't to the spec and they've invented this behaviour which is\n      // **extremely** annoying so we avoid setting the name if it has a param\n      // with the same id\n      state.needsRename = true;\n    } else {\n      // otherwise it's defined somewhere in scope like:\n      //\n      //   let t = function () {\n      //     let t = 2;\n      //   };\n      //\n      // so we can safely just set the id and move along as it shadows the\n      // bound function id\n    }\n  } else if (scope.parent.hasBinding(name) || scope.hasGlobal(name)) {\n    this.traverse(refersOuterBindingVisitor, state);\n  }\n\n  if (!state.needsRename) {\n    this.node.id = id;\n    scope.getProgramParent().references[id.name] = true;\n    return this;\n  }\n\n  if (scope.hasBinding(id.name) && !scope.hasGlobal(id.name)) {\n    // we can just munge the local binding\n    scope.rename(id.name);\n    this.node.id = id;\n    scope.getProgramParent().references[id.name] = true;\n    return this;\n  }\n\n  // TODO: we don't currently support wrapping class expressions\n  if (!isFunction(this.node)) return null;\n\n  // need to add a wrapper since we can't change the references\n\n  const key = scope.generateUidIdentifier(id.name);\n  // shim in dummy params to retain function arity, if you try to read the\n  // source then you'll get the original since it's proxied so it's all good\n  const params = [];\n  for (let i = 0, len = getFunctionArity(this.node); i < len; i++) {\n    params.push(scope.generateUidIdentifier(\"x\"));\n  }\n  const call = template.expression.ast`\n    (function (${key}) {\n      function ${id}(${params}) {\n        return ${cloneNode(key)}.apply(this, arguments);\n      }\n\n      ${cloneNode(id)}.toString = function () {\n        return ${cloneNode(key)}.toString();\n      }\n\n      return ${cloneNode(id)};\n    })(${toExpression(this.node)})\n  ` as t.CallExpression;\n\n  return this.replaceWith(call)[0].get(\"arguments.0\") as NodePath<N>;\n}\n\nfunction getFunctionArity(node: t.Function): number {\n  const count = node.params.findIndex(\n    param => isAssignmentPattern(param) || isRestElement(param),\n  );\n  return count === -1 ? node.params.length : count;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}