{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar t = require(\"@babel/types\");\nvar _traverseNode = require(\"../../traverse-node.js\");\nvar _visitors = require(\"../../visitors.js\");\nvar _context = require(\"../../path/context.js\");\nconst renameVisitor = {\n  ReferencedIdentifier(_ref, state) {\n    let {\n      node\n    } = _ref;\n    if (node.name === state.oldName) {\n      node.name = state.newName;\n    }\n  },\n  Scope(path, state) {\n    if (!path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {\n      path.skip();\n      if (path.isMethod()) {\n        if (!path.requeueComputedKeyAndDecorators) {\n          _context.requeueComputedKeyAndDecorators.call(path);\n        } else {\n          path.requeueComputedKeyAndDecorators();\n        }\n      }\n    }\n  },\n  ObjectProperty(_ref2, state) {\n    let {\n      node,\n      scope\n    } = _ref2;\n    const {\n      name\n    } = node.key;\n    if (node.shorthand && (name === state.oldName || name === state.newName) && scope.getBindingIdentifier(name) === state.binding.identifier) {\n      node.shorthand = false;\n      {\n        var _node$extra;\n        if ((_node$extra = node.extra) != null && _node$extra.shorthand) node.extra.shorthand = false;\n      }\n    }\n  },\n  \"AssignmentExpression|Declaration|VariableDeclarator\"(path, state) {\n    if (path.isVariableDeclaration()) return;\n    const ids = path.isAssignmentExpression() ? path.getAssignmentIdentifiers() : path.getOuterBindingIdentifiers();\n    for (const name in ids) {\n      if (name === state.oldName) ids[name].name = state.newName;\n    }\n  }\n};\nclass Renamer {\n  constructor(binding, oldName, newName) {\n    this.newName = newName;\n    this.oldName = oldName;\n    this.binding = binding;\n  }\n  maybeConvertFromExportDeclaration(parentDeclar) {\n    const maybeExportDeclar = parentDeclar.parentPath;\n    if (!maybeExportDeclar.isExportDeclaration()) {\n      return;\n    }\n    if (maybeExportDeclar.isExportDefaultDeclaration()) {\n      const {\n        declaration\n      } = maybeExportDeclar.node;\n      if (t.isDeclaration(declaration) && !declaration.id) {\n        return;\n      }\n    }\n    if (maybeExportDeclar.isExportAllDeclaration()) {\n      return;\n    }\n    maybeExportDeclar.splitExportDeclaration();\n  }\n  maybeConvertFromClassFunctionDeclaration(path) {\n    return path;\n  }\n  maybeConvertFromClassFunctionExpression(path) {\n    return path;\n  }\n  rename() {\n    const {\n      binding,\n      oldName,\n      newName\n    } = this;\n    const {\n      scope,\n      path\n    } = binding;\n    const parentDeclar = path.find(path => path.isDeclaration() || path.isFunctionExpression() || path.isClassExpression());\n    if (parentDeclar) {\n      const bindingIds = parentDeclar.getOuterBindingIdentifiers();\n      if (bindingIds[oldName] === binding.identifier) {\n        this.maybeConvertFromExportDeclaration(parentDeclar);\n      }\n    }\n    const blockToTraverse = arguments[0] || scope.block;\n    (0, _traverseNode.traverseNode)(blockToTraverse, (0, _visitors.explode)(renameVisitor), scope, this, scope.path, {\n      discriminant: true\n    });\n    if (!arguments[0]) {\n      scope.removeOwnBinding(oldName);\n      scope.bindings[newName] = binding;\n      this.binding.identifier.name = newName;\n    }\n    if (parentDeclar) {\n      this.maybeConvertFromClassFunctionDeclaration(path);\n      this.maybeConvertFromClassFunctionExpression(path);\n    }\n  }\n}\nexports.default = Renamer;","map":{"version":3,"names":["t","require","_traverseNode","_visitors","_context","renameVisitor","ReferencedIdentifier","_ref","state","node","name","oldName","newName","Scope","path","scope","bindingIdentifierEquals","binding","identifier","skip","isMethod","requeueComputedKeyAndDecorators","call","ObjectProperty","_ref2","key","shorthand","getBindingIdentifier","_node$extra","extra","AssignmentExpression|Declaration|VariableDeclarator","isVariableDeclaration","ids","isAssignmentExpression","getAssignmentIdentifiers","getOuterBindingIdentifiers","Renamer","constructor","maybeConvertFromExportDeclaration","parentDeclar","maybeExportDeclar","parentPath","isExportDeclaration","isExportDefaultDeclaration","declaration","isDeclaration","id","isExportAllDeclaration","splitExportDeclaration","maybeConvertFromClassFunctionDeclaration","maybeConvertFromClassFunctionExpression","rename","find","isFunctionExpression","isClassExpression","bindingIds","blockToTraverse","arguments","block","traverseNode","explode","discriminant","removeOwnBinding","bindings","exports","default"],"sources":["G:\\Event Event Hub\\Frontend\\abhijeetproject\\node_modules\\@babel\\traverse\\src\\scope\\lib\\renamer.ts"],"sourcesContent":["import type Binding from \"../binding.ts\";\nimport * as t from \"@babel/types\";\nimport type { NodePath, Visitor } from \"../../index.ts\";\nimport { traverseNode } from \"../../traverse-node.ts\";\nimport { explode } from \"../../visitors.ts\";\nimport type { Identifier } from \"@babel/types\";\nimport { requeueComputedKeyAndDecorators } from \"../../path/context.ts\";\n\nconst renameVisitor: Visitor<Renamer> = {\n  ReferencedIdentifier({ node }, state) {\n    if (node.name === state.oldName) {\n      node.name = state.newName;\n    }\n  },\n\n  Scope(path, state) {\n    if (\n      !path.scope.bindingIdentifierEquals(\n        state.oldName,\n        state.binding.identifier,\n      )\n    ) {\n      path.skip();\n      if (path.isMethod()) {\n        if (\n          !process.env.BABEL_8_BREAKING &&\n          !path.requeueComputedKeyAndDecorators\n        ) {\n          // See https://github.com/babel/babel/issues/16694\n          requeueComputedKeyAndDecorators.call(path);\n        } else {\n          path.requeueComputedKeyAndDecorators();\n        }\n      }\n    }\n  },\n\n  ObjectProperty({ node, scope }, state) {\n    const { name } = node.key as Identifier;\n    if (\n      node.shorthand &&\n      // In destructuring the identifier is already renamed by the\n      // AssignmentExpression|Declaration|VariableDeclarator visitor,\n      // while in object literals it's renamed later by the\n      // ReferencedIdentifier visitor.\n      (name === state.oldName || name === state.newName) &&\n      // Ignore shadowed bindings\n      scope.getBindingIdentifier(name) === state.binding.identifier\n    ) {\n      node.shorthand = false;\n      if (!process.env.BABEL_8_BREAKING) {\n        if (node.extra?.shorthand) node.extra.shorthand = false;\n      }\n    }\n  },\n\n  \"AssignmentExpression|Declaration|VariableDeclarator\"(\n    path: NodePath<\n      t.AssignmentExpression | t.Declaration | t.VariableDeclarator\n    >,\n    state,\n  ) {\n    if (path.isVariableDeclaration()) return;\n    const ids = path.isAssignmentExpression()\n      ? path.getAssignmentIdentifiers()\n      : path.getOuterBindingIdentifiers();\n\n    for (const name in ids) {\n      if (name === state.oldName) ids[name].name = state.newName;\n    }\n  },\n};\n\nexport default class Renamer {\n  constructor(binding: Binding, oldName: string, newName: string) {\n    this.newName = newName;\n    this.oldName = oldName;\n    this.binding = binding;\n  }\n\n  declare oldName: string;\n  declare newName: string;\n  declare binding: Binding;\n\n  maybeConvertFromExportDeclaration(parentDeclar: NodePath) {\n    const maybeExportDeclar = parentDeclar.parentPath;\n\n    if (!maybeExportDeclar.isExportDeclaration()) {\n      return;\n    }\n\n    if (maybeExportDeclar.isExportDefaultDeclaration()) {\n      const { declaration } = maybeExportDeclar.node;\n      if (t.isDeclaration(declaration) && !declaration.id) {\n        return;\n      }\n    }\n\n    if (maybeExportDeclar.isExportAllDeclaration()) {\n      return;\n    }\n\n    maybeExportDeclar.splitExportDeclaration();\n  }\n\n  maybeConvertFromClassFunctionDeclaration(path: NodePath) {\n    return path; // TODO\n\n    // // retain the `name` of a class/function declaration\n\n    // if (!path.isFunctionDeclaration() && !path.isClassDeclaration()) return;\n    // if (this.binding.kind !== \"hoisted\") return;\n\n    // path.node.id = identifier(this.oldName);\n    // path.node._blockHoist = 3;\n\n    // path.replaceWith(\n    //   variableDeclaration(\"let\", [\n    //     variableDeclarator(identifier(this.newName), toExpression(path.node)),\n    //   ]),\n    // );\n  }\n\n  maybeConvertFromClassFunctionExpression(path: NodePath) {\n    return path; // TODO\n\n    // // retain the `name` of a class/function expression\n\n    // if (!path.isFunctionExpression() && !path.isClassExpression()) return;\n    // if (this.binding.kind !== \"local\") return;\n\n    // path.node.id = identifier(this.oldName);\n\n    // this.binding.scope.parent.push({\n    //   id: identifier(this.newName),\n    // });\n\n    // path.replaceWith(\n    //   assignmentExpression(\"=\", identifier(this.newName), path.node),\n    // );\n  }\n\n  rename(/* Babel 7 - block?: t.Pattern | t.Scopable */) {\n    const { binding, oldName, newName } = this;\n    const { scope, path } = binding;\n\n    const parentDeclar = path.find(\n      path =>\n        path.isDeclaration() ||\n        path.isFunctionExpression() ||\n        path.isClassExpression(),\n    );\n    if (parentDeclar) {\n      const bindingIds = parentDeclar.getOuterBindingIdentifiers();\n      if (bindingIds[oldName] === binding.identifier) {\n        // When we are renaming an exported identifier, we need to ensure that\n        // the exported binding keeps the old name.\n        this.maybeConvertFromExportDeclaration(parentDeclar);\n      }\n    }\n\n    const blockToTraverse = process.env.BABEL_8_BREAKING\n      ? scope.block\n      : (arguments[0] as t.Pattern | t.Scopable) || scope.block;\n    traverseNode(\n      blockToTraverse,\n      explode(renameVisitor),\n      scope,\n      this,\n      scope.path,\n      // When blockToTraverse is a SwitchStatement, the discriminant\n      // is not part of the current scope and thus should be skipped.\n      { discriminant: true },\n    );\n\n    if (process.env.BABEL_8_BREAKING) {\n      scope.removeOwnBinding(oldName);\n      scope.bindings[newName] = binding;\n      this.binding.identifier.name = newName;\n    } else if (!arguments[0]) {\n      scope.removeOwnBinding(oldName);\n      scope.bindings[newName] = binding;\n      this.binding.identifier.name = newName;\n    }\n\n    if (parentDeclar) {\n      this.maybeConvertFromClassFunctionDeclaration(path);\n      this.maybeConvertFromClassFunctionExpression(path);\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}